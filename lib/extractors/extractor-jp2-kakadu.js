// Generated by CoffeeScript 1.10.0
(function() {
  var ConvertManipulator, ExtractorJP2Kakadu, SharpManipulator, _, async, child_process, fs, tempfile,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  tempfile = require('tempfile');

  child_process = require('child_process');

  async = require('async');

  fs = require('fs');

  _ = require('lodash');

  ConvertManipulator = require('../manipulators/convert-manipulator').ConvertManipulator;

  SharpManipulator = require('../manipulators/sharp-manipulator').SharpManipulator;

  ExtractorJP2Kakadu = (function() {
    function ExtractorJP2Kakadu(options, final_callback) {
      this.options = options;
      this.final_callback = final_callback;
      this.extract = bind(this.extract, this);
      this.path = this.options.path;
      this.info = this.options.info;
      this.params = this.options.params;
      this.temp_bmp = tempfile('.bmp');
      this.final_image = tempfile("." + this.params.format);
      this.manipulator = new SharpManipulator(this.temp_bmp, this.params, this.final_image);
    }

    ExtractorJP2Kakadu.prototype.extract = function() {
      var kdu_expand_cmd;
      kdu_expand_cmd = this.kdu_expand_cmd();
      return async.waterfall([
        function(seriescb) {
          return child_process.exec(kdu_expand_cmd, (function(_this) {
            return function(err, stdout, stderr) {
              return seriescb();
            };
          })(this));
        }, (function(_this) {
          return function(seriescb) {
            return _this.manipulator.manipulate(seriescb);
          };
        })(this), (function(_this) {
          return function(image_buffer, info, seriescb) {
            seriescb();
            return _this.final_callback(image_buffer);
          };
        })(this), (function(_this) {
          return function(seriescb) {
            return fs.unlink(_this.temp_bmp);
          };
        })(this)
      ]);
    };

    ExtractorJP2Kakadu.prototype.kdu_expand_cmd = function() {
      var cmd, height, height_pct, left, left_pct, reduction, ref, ref1, top, top_pct, width, width_pct;
      if (this.params.region === 'full') {
        ref = [0, 0, this.info.height, this.info.width], top = ref[0], left = ref[1], height = ref[2], width = ref[3];
      } else {
        ref1 = [this.params.region.y, this.params.region.x, this.params.region.h, this.params.region.w], top = ref1[0], left = ref1[1], height = ref1[2], width = ref1[3];
      }
      top_pct = top / this.info.height;
      left_pct = left / this.info.width;
      height_pct = height / this.info.height;
      width_pct = width / this.info.width;
      cmd = "kdu_expand -i " + this.path + " -o " + this.temp_bmp + " -region '{" + top_pct + "," + left_pct + "},{" + height_pct + "," + width_pct + "}'";
      reduction = this.params.size === 'full' ? 0 : this.pick_reduction();
      return cmd + (" -reduce " + reduction);
    };


    /*
    TODO: optimize pick_reduction
    This could be improved to be more exact in the reduction to pick. In some cases
    where the image requested is the same as the size of on of the quality layers
    it will pick a larger layer than it needs to.
     */

    ExtractorJP2Kakadu.prototype.pick_reduction = function() {
      var current_level, i, index, len, reduction_factor, reduction_scale_matches, region_height, region_width, same_or_bigger, scale_factor, scale_factor_reduction, scale_factors;
      if (this.params.size.w != null) {
        region_width = this.params.region === 'full' ? this.info.width : this.params.region.w;
        reduction_factor = region_width / this.params.size.w;
      } else {
        region_height = this.params.region === 'full' ? this.info.height : this.params.region.h;
        reduction_factor = region_height / this.params.size.h;
      }
      scale_factors = this.info.tiles[0].scaleFactors.reverse();
      reduction_scale_matches = [];
      current_level = this.info.levels;
      for (index = i = 0, len = scale_factors.length; i < len; index = ++i) {
        scale_factor = scale_factors[index];
        scale_factor_reduction = {
          scale_factor: scale_factor,
          reduction: current_level
        };
        reduction_scale_matches.push(scale_factor_reduction);
        current_level -= 1;
      }
      same_or_bigger = _.filter(reduction_scale_matches, function(rsm) {
        return reduction_factor >= rsm.scale_factor;
      });
      return same_or_bigger[0].reduction;
    };

    return ExtractorJP2Kakadu;

  })();

  exports.ExtractorJP2Kakadu = ExtractorJP2Kakadu;

}).call(this);
