// Generated by CoffeeScript 1.10.0

/*
Validates Image Request URL parameters as well as whether the
requested region is out of bounds (if image info is given as well).
Except for rotation values it will determine whether the request is
valid according to the specification and not necessarily whether
any image server supports particular values. For instance the specification
lists webp as a valid format though

TODO: extend the validations to allow for support levels to be given to more accurately reflect what any particular image server might actually support.
 */

(function() {
  var Validator, _, type;

  _ = require('lodash');


  /*
  From
   */

  type = (function() {
    var classToType, i, len, name, ref;
    classToType = {};
    ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var strType;
      strType = Object.prototype.toString.call(obj);
      return classToType[strType] || "object";
    };
  })();

  Validator = (function() {
    function Validator(params, info) {
      this.params = params;
      this.info = info;
    }

    Validator.prototype.valid = function() {
      if (this.valid_params() && !this.out_of_bounds()) {
        return true;
      } else {
        return false;
      }
    };


    /*
    Only checks that the format of the request params is correct. Does not check
    for whether is matches up with the image information in a way that can be
    successful.
     */

    Validator.prototype.valid_params = function() {
      if (this.valid_region() && this.valid_size() && this.valid_rotation() && this.valid_quality() && this.valid_format()) {
        return true;
      } else {
        return false;
      }
    };

    Validator.prototype.valid_region = function() {
      var region;
      region = this.params.region;
      if (type(region) === 'string') {
        if (region === 'full' || region === 'square' || region === '!square' || region === 'square!') {
          return true;
        } else {
          return false;
        }
      } else if (type(region) === 'object') {
        if (this.valid_region_xywh()) {
          if (region.w > 0 && region.h > 0) {
            return true;
          } else {
            return false;
          }
        } else if (this.valid_region_pct_xywh()) {
          if (region.pctw > 0 && region.pcth > 0) {
            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    Validator.prototype.valid_region_xywh = function() {
      var region;
      region = this.params.region;
      return type(region.x) === 'number' && !isNaN(region.x) && type(region.y) === 'number' && !isNaN(region.y) && type(region.w) === 'number' && !isNaN(region.w) && type(region.h) === 'number' && !isNaN(region.h);
    };

    Validator.prototype.valid_region_pct_xywh = function() {
      var region;
      region = this.params.region;
      return type(region.pctx) === 'number' && !isNaN(region.pctx) && type(region.pcty) === 'number' && !isNaN(region.pcty) && type(region.pctw) === 'number' && !isNaN(region.pctw) && type(region.pcth) === 'number' && !isNaN(region.pcth);
    };

    Validator.prototype.valid_size = function() {
      var size;
      size = this.params.size;
      if (type(size) === 'string') {
        if (size === 'full') {
          return true;
        } else {
          return false;
        }
      } else if (type(size) === 'object') {
        if (size.w === 0 || size.h === 0) {
          return false;
        } else if (type(size.w) === 'number' && type(size.h) === 'number') {
          return true;
        } else if (type(size.w) === 'number' && (size.h == null)) {
          return true;
        } else if ((size.w == null) && type(size.h) === 'number') {
          return true;
        } else if (type(size.pct) === 'number') {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    Validator.prototype.valid_rotation = function() {
      var rotation;
      rotation = this.params.rotation;
      if (type(rotation.degrees) === 'number') {
        if (_.includes([0, 90, 180, 270], rotation.degrees)) {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    Validator.prototype.valid_quality = function() {
      var valid_qualities;
      valid_qualities = ['color', 'gray', 'bitonal', 'default'];
      if (_.includes(valid_qualities, this.params.quality)) {
        return true;
      } else {
        return false;
      }
    };

    Validator.prototype.valid_format = function() {
      var valid_formats;
      valid_formats = ['jpg', 'tif', 'png', 'gif', 'jp2', 'pdf', 'webp'];
      if (_.includes(valid_formats, this.params.format)) {
        return true;
      } else {
        return false;
      }
    };

    Validator.prototype.out_of_bounds = function() {
      var region;
      region = this.params.region;
      if (((region.x != null) && region.x > this.info.width) || ((region.y != null) && region.y > this.info.height)) {
        return true;
      } else {
        return false;
      }
    };

    return Validator;

  })();

  exports.Validator = Validator;

}).call(this);
